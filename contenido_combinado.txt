

--- Contenido de app/main.py ---

from fastapi import FastAPI
from app.core.config import settings
from app.api.endpoints import auth, usuario_completo, persona
from app.core.app_config import setup_app_config
from app.core.error_handling import global_exception_handler, AppException
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from app.middleware.actividad_middleware import ActividadMiddleware

app = FastAPI(title=settings.PROJECT_NAME, version=settings.VERSION)

setup_app_config(app)

# Registrar el manejador de excepciones global
app.add_exception_handler(AppException, global_exception_handler)
app.add_exception_handler(StarletteHTTPException, global_exception_handler)
app.add_exception_handler(RequestValidationError, global_exception_handler)
app.add_exception_handler(Exception, global_exception_handler)

app.add_middleware(ActividadMiddleware)

app.include_router(auth.router, prefix=f"{settings.API_V1_STR}/authentication", tags=["auth"])
app.include_router(usuario_completo.router, prefix=f"{settings.API_V1_STR}/usuario-completo", tags=["usuario-completo"])
app.include_router(persona.router, prefix=f"{settings.API_V1_STR}/personas", tags=["personas"])



@app.get("/")
async def root():
    return {"message": "Hello World"}

--- Contenido de app/api\endpoints\auth.py ---

from fastapi import APIRouter, Depends, Request, Response, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.core.config import settings
from app.core.database import get_db
from app.schemas.auth import TokenRespuesta, UsuarioRespuesta
from app.core.auth import create_access_token, get_current_user, authenticate_user
from app.core.error_handling import AppException
from datetime import timedelta

from app.utils.sesion_util import registrar_fin_sesion, registrar_inicio_sesion

router = APIRouter()

@router.post("/login", response_model=TokenRespuesta)
async def login_for_access_token(
    response: Response,
    request: Request,
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db),
):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise AppException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales incorrectas"
        )
    if not user.esta_activo:
        raise AppException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Usuario inactivo"
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.nombre_usuario}, expires_delta=access_token_expires
    )
    
    # Registrar el inicio de sesión
    registrar_inicio_sesion(db, user.id, access_token, request)
    
    response.set_cookie(
        key="access_token",
        value=f"Bearer {access_token}",
        httponly=True,
        max_age=1800,
        expires=1800,
        samesite='lax',
        secure=False  # Set to True in production with HTTPS
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/logout")
async def logout(response: Response, request: Request, db: Session = Depends(get_db)):
    token = request.cookies.get("access_token")
    if token and token.startswith("Bearer "):
        token = token.split("Bearer ")[1]
        registrar_fin_sesion(db, token)
    
    response.delete_cookie(key="access_token")
    return {"message": "Sesión cerrada exitosamente"}

@router.get("/me", response_model=UsuarioRespuesta)
async def read_users_me(current_user: UsuarioRespuesta = Depends(get_current_user)):
    return current_user

--- Contenido de app/api\endpoints\persona.py ---

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from app.core.auth import get_current_user
from app.core.database import get_db
from app.schemas.persona import PersonaCreacionSchema, PersonaRespuestaSchema, PersonaActualizacionSchema, PersonaPaginada
from app.crud import crud_persona
from app.core.permissions import require_permissions
from app.schemas.auth import UsuarioRespuesta

router = APIRouter()

@router.post("/", response_model=PersonaRespuestaSchema)
@require_permissions("persona:crear")
async def crear_persona(
    persona: PersonaCreacionSchema,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    return crud_persona.crear_persona(db=db, persona=persona, creado_por=current_user.id)

@router.get("/{persona_id}", response_model=PersonaRespuestaSchema)
@require_permissions("persona:leer")
async def obtener_persona(
    persona_id: int,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    db_persona = crud_persona.obtener_persona(db, persona_id=persona_id)
    if db_persona is None:
        raise HTTPException(status_code=404, detail="Persona no encontrada")
    return db_persona

@router.get("/", response_model=PersonaPaginada)
@require_permissions("persona:leer")
async def listar_personas(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    personas, total = crud_persona.listar_personas(db, skip=skip, limit=limit)
    return PersonaPaginada(
        total=total,
        page=skip // limit + 1,
        pages=(total + limit - 1) // limit,
        limit=limit,
        prev_page=skip // limit if skip > 0 else None,
        next_page=skip // limit + 2 if skip + limit < total else None,
        items=personas
    )

@router.put("/{persona_id}", response_model=PersonaRespuestaSchema)
@require_permissions("persona:actualizar")
async def actualizar_persona(
    persona_id: int,
    persona: PersonaActualizacionSchema,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    return crud_persona.actualizar_persona(
        db=db,
        persona_id=persona_id,
        persona=persona,
        actualizado_por=current_user.id
    )

@router.delete("/{persona_id}", response_model=PersonaRespuestaSchema)
@require_permissions("persona:eliminar")
async def eliminar_persona(
    persona_id: int,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    return crud_persona.eliminar_persona(
        db=db,
        persona_id=persona_id,
        eliminado_por=current_user.id
    )

@router.post("/{persona_id}/restaurar", response_model=PersonaRespuestaSchema)
@require_permissions("persona:restaurar")
async def restaurar_persona(
    persona_id: int,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    return crud_persona.restaurar_persona(db=db, persona_id=persona_id, actualizado_por=current_user.id)

--- Contenido de app/api\endpoints\usuario_completo.py ---

import math
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
from app.core.auth import get_current_user
from app.core.database import get_db
from app.schemas import UsuarioCompletoCreacionSchema, UsuarioCompletoRespuestaSchema
from app.crud import crud_usuario_completo
from app.core.permissions import require_permissions
from app.schemas.auth import UsuarioRespuesta
from app.schemas.usuario_completo import UsuarioCompletoActualizacionSchema, UsuarioCompletoPaginado

router = APIRouter()

@router.post("/", response_model=UsuarioCompletoRespuestaSchema)
@require_permissions("usuario:crear")
async def crear_usuario_completo(
    usuario: UsuarioCompletoCreacionSchema,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    return crud_usuario_completo.crear_usuario_completo(
        db=db, 
        usuario_data=usuario, 
        creado_por=current_user.id
    )

@router.get("/{usuario_id}", response_model=UsuarioCompletoRespuestaSchema,)
@require_permissions("usuario:leer")
async def obtener_usuario_completo(usuario_id: int, db: Session = Depends(get_db),current_user: UsuarioRespuesta = Depends(get_current_user)):
    db_usuario = crud_usuario_completo.obtener_usuario_completo(db, usuario_id=usuario_id)
    if db_usuario is None:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return db_usuario

@router.get("/", response_model=UsuarioCompletoPaginado)
@require_permissions("usuario:leer")
async def listar_usuarios_completos(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    usuarios, total = crud_usuario_completo.listar_usuarios_completos(db, skip=skip, limit=limit)
    
    total_pages = max(1, math.ceil(total / limit))
    current_page = min(skip // limit + 1, total_pages)
    
    return UsuarioCompletoPaginado(
        total=total,
        page=current_page,
        pages=total_pages,
        limit=limit,
        prev_page=current_page - 1 if current_page > 1 else None,
        next_page=current_page + 1 if current_page < total_pages else None,
        items=usuarios
    )

@router.put("/{usuario_id}", response_model=UsuarioCompletoRespuestaSchema)
@require_permissions("usuario:actualizar")
async def actualizar_usuario_completo(
    usuario_id: int,
    usuario: UsuarioCompletoActualizacionSchema,
    db: Session = Depends(get_db),
    current_user: UsuarioRespuesta = Depends(get_current_user)
):
    return crud_usuario_completo.actualizar_usuario_completo(
        db=db, 
        usuario_id=usuario_id, 
        usuario_data=usuario,
        actualizado_por=current_user.id
    )


--- Contenido de app/core\app_config.py ---

from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.utils import get_openapi

def setup_cors(app):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:5173"],  # Ajusta esto según tus necesidades
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

def custom_openapi(app):
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Tu API",
        version="1.0.0",
        description="Descripción de tu API",
        routes=app.routes,
    )
    openapi_schema["components"]["securitySchemes"] = {
        "Bearer Auth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    }
    
    for path in openapi_schema["paths"]:
        for method in openapi_schema["paths"][path]:
            if openapi_schema["paths"][path][method].get("operationId") not in ["login_for_access_token", "root"]:
                openapi_schema["paths"][path][method]["security"] = [{"Bearer Auth": []}]
    
    app.openapi_schema = openapi_schema
    return app.openapi_schema

def setup_app_config(app):
    setup_cors(app)
    app.openapi = lambda: custom_openapi(app)

--- Contenido de app/core\auth.py ---

from datetime import datetime, timedelta
from typing import Optional

from fastapi import Depends, HTTPException, status, Request
from jose import JWTError, jwt
from sqlalchemy.orm import Session

from app.core.config import settings
from app.core.security import verify_password
from app.crud import crud_auth
from app.core.database import get_db
from app.schemas.auth import TokenPayload, UsuarioRespuesta, RolRespuesta, PermisoRespuesta

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(request: Request, db: Session = Depends(get_db)) -> UsuarioRespuesta:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    token = await get_token_from_request(request)
    if not token:
        raise credentials_exception
    
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        nombre_usuario: str = payload.get("sub")
        if nombre_usuario is None:
            raise credentials_exception
        token_data = TokenPayload(nombre_usuario=nombre_usuario)
    except JWTError:
        raise credentials_exception
    user = crud_auth.get_by_nombre_usuario(db, nombre_usuario=token_data.nombre_usuario)
    if user is None:
        raise credentials_exception
    
    rol = user.rol
    return UsuarioRespuesta(
        id=user.id,
        nombre_usuario=user.nombre_usuario,
        esta_activo=user.esta_activo,
        es_superusuario=user.es_superusuario,
        nombre=user.persona.nombre,
        apellido=user.persona.apellido,
        fecha_nacimiento=user.persona.fecha_nacimiento,
        email=user.persona.email,
        rol=RolRespuesta(
            id=rol.id,
            nombre=rol.nombre,
            descripcion=rol.descripcion,
            permisos=[PermisoRespuesta(
                id=permiso.id,
                nombre=permiso.nombre,
                descripcion=permiso.descripcion
            ) for permiso in rol.permisos]
        ) if rol else None
    )

def authenticate_user(db: Session, username: str, password: str):
    user = crud_auth.get_by_nombre_usuario(db, nombre_usuario=username)
    if not user:
        return False
    if not verify_password(password, user.hash_contrasena):
        return False
    return user

async def get_token_from_request(request: Request) -> str | None:
    token = request.cookies.get("access_token")
    if token and token.startswith("Bearer "):
        return token.split("Bearer ")[1]
    return token

--- Contenido de app/core\config.py ---

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    PROJECT_NAME: str = "Tu API"
    VERSION: str = "0.1.0"
    DATABASE_URL: str = "postgresql://postgres:admin@localhost/postgres"
    API_V1_STR: str = "/api/v1"
    SECRET_KEY: str = "YOUR_SECRET_KEY_HERE"  # Cambia esto por una clave secreta real
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    class Config:
        env_file = ".env"

settings = Settings()

--- Contenido de app/core\database.py ---

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


--- Contenido de app/core\error_handling.py ---

from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from typing import Union, Dict, Any
from pydantic import ValidationError

class AppException(Exception):
    def __init__(self, status_code: int, detail: str):
        self.status_code = status_code
        self.detail = detail

def create_error_response(status_code: int, detail: Union[str, Dict[str, Any]]) -> Dict[str, Any]:
    # Si detail es una lista o diccionario, lo dejamos como está
    if isinstance(detail, (list, dict)):
        formatted_detail = detail
    # Si es una excepción, convertimos su mensaje a string
    elif isinstance(detail, Exception):
        formatted_detail = str(detail)
    # Si es un string, lo dejamos como está
    else:
        formatted_detail = detail

    return {
        "error": {
            "status_code": status_code,
            "detail": formatted_detail
        }
    }

async def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    if isinstance(exc, AppException):
        return JSONResponse(
            status_code=exc.status_code,
            content=create_error_response(exc.status_code, exc.detail)
        )
    elif isinstance(exc, StarletteHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content=create_error_response(exc.status_code, exc.detail)
        )
    elif isinstance(exc, RequestValidationError):
        errors = []
        for error in exc.errors():
            error_detail = {
                "loc": error.get("loc", []),
                "msg": error.get("msg", ""),
                "type": error.get("type", "")
            }
            if "ctx" in error:
                error_detail["ctx"] = error["ctx"]
            errors.append(error_detail)
            
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content=create_error_response(status.HTTP_422_UNPROCESSABLE_ENTITY, errors)
        )
    elif isinstance(exc, ValueError):
        # Manejar específicamente los errores de ValueError (como los de validación de RUT)
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content=create_error_response(
                status.HTTP_400_BAD_REQUEST,
                str(exc)
            )
        )
    else:
        # Para excepciones no manejadas, devolver un error 500
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content=create_error_response(
                status.HTTP_500_INTERNAL_SERVER_ERROR,
                "Se ha producido un error interno del servidor"
            )
        )

--- Contenido de app/core\permissions.py ---

from functools import wraps
from fastapi import HTTPException, Depends
from app.core.auth import get_current_user
from app.schemas.auth import UsuarioRespuesta

def require_permissions(*required_permissions):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, current_user: UsuarioRespuesta = Depends(get_current_user), **kwargs):
            if current_user.es_superusuario:
                return await func(*args, current_user=current_user, **kwargs)
            
            user_permissions = set(permiso.nombre for permiso in current_user.rol.permisos)
            
            if not set(required_permissions).issubset(user_permissions):
                raise HTTPException(status_code=403, detail="No tienes permisos suficientes para realizar esta acción")
            
            return await func(*args, current_user=current_user, **kwargs)
        return wrapper
    return decorator

--- Contenido de app/core\security.py ---

from datetime import datetime, timedelta, timezone
from typing import Any, Union

from jose import jwt
from passlib.context import CryptContext

from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_access_token(subject: Union[str, Any], expires_delta: timedelta = None) -> str:
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

--- Contenido de app/crud\crud_auth.py ---

from sqlalchemy.orm import Session
from app.models.usuario import Usuario


def get_by_nombre_usuario(db: Session, nombre_usuario: str) -> Usuario:
        return db.query(Usuario).filter(Usuario.nombre_usuario == nombre_usuario).first()

--- Contenido de app/crud\crud_persona.py ---

from sqlalchemy.orm import Session
from sqlalchemy import func
from fastapi import HTTPException
from app.models.persona import Persona
from app.schemas.persona import PersonaCreacionSchema, PersonaActualizacionSchema
from datetime import datetime

def crear_persona(db: Session, persona: PersonaCreacionSchema, creado_por: int):
    # Verificar si existe el email
    db_persona = db.query(Persona).filter(
        Persona.email == persona.email,
        Persona.eliminado_en.is_(None)
    ).first()
    if db_persona:
        raise HTTPException(status_code=400, detail="El email ya está registrado")
        
    # Verificar si existe el RUT
    db_persona = db.query(Persona).filter(
        Persona.rut == persona.rut,
        Persona.eliminado_en.is_(None)
    ).first()
    if db_persona:
        raise HTTPException(status_code=400, detail="El RUT ya está registrado")

    nueva_persona = Persona(**persona.model_dump(), creado_por=creado_por)
    db.add(nueva_persona)
    db.commit()
    db.refresh(nueva_persona)
    return nueva_persona

def obtener_persona(db: Session, persona_id: int):
    return db.query(Persona).filter(Persona.id == persona_id, Persona.eliminado_en.is_(None)).first()

def listar_personas(db: Session, skip: int = 0, limit: int = 100):
    total = db.query(func.count(Persona.id)).filter(Persona.eliminado_en.is_(None)).scalar()
    personas = db.query(Persona).filter(Persona.eliminado_en.is_(None)).offset(skip).limit(limit).all()
    return personas, total

def listar_personas_eliminadas(db: Session, skip: int = 0, limit: int = 100):
    total = db.query(func.count(Persona.id)).filter(Persona.eliminado_en.isnot(None)).scalar()
    personas = db.query(Persona).filter(Persona.eliminado_en.isnot(None)).offset(skip).limit(limit).all()
    return personas, total

def actualizar_persona(db: Session, persona_id: int, persona: PersonaActualizacionSchema, actualizado_por: int):
    db_persona = db.query(Persona).filter(Persona.id == persona_id, Persona.eliminado_en.is_(None)).first()
    if not db_persona:
        raise HTTPException(status_code=404, detail="Persona no encontrada")
    
    # Verificar email si se está actualizando
    if persona.email and persona.email != db_persona.email:
        existing_persona = db.query(Persona).filter(
            Persona.email == persona.email,
            Persona.id != persona_id,
            Persona.eliminado_en.is_(None)
        ).first()
        if existing_persona:
            raise HTTPException(status_code=400, detail="El email ya está registrado")
    
    # Verificar RUT si se está actualizando
    if persona.rut and persona.rut != db_persona.rut:
        existing_persona = db.query(Persona).filter(
            Persona.rut == persona.rut,
            Persona.id != persona_id,
            Persona.eliminado_en.is_(None)
        ).first()
        if existing_persona:
            raise HTTPException(status_code=400, detail="El RUT ya está registrado")
    
    update_data = persona.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_persona, key, value)
    
    db_persona.actualizado_por = actualizado_por
    
    db.commit()
    db.refresh(db_persona)
    return db_persona

def eliminar_persona(db: Session, persona_id: int, eliminado_por: int):
    db_persona = db.query(Persona).filter(Persona.id == persona_id, Persona.eliminado_en.is_(None)).first()
    if not db_persona:
        raise HTTPException(status_code=404, detail="Persona no encontrada")
    
    db_persona.eliminado_en = func.now()
    db_persona.eliminado_por = eliminado_por
    
    db.commit()
    return db_persona

def restaurar_persona(db: Session, persona_id: int, actualizado_por: int):
    db_persona = db.query(Persona).filter(Persona.id == persona_id, Persona.eliminado_en.isnot(None)).first()
    if not db_persona:
        raise HTTPException(status_code=404, detail="Persona eliminada no encontrada")
    
    db_persona.eliminado_en = None
    db_persona.eliminado_por = None
    
    db_persona.actualizado_en = func.now()
    db_persona.actualizado_por = actualizado_por
    
    db.commit()
    db.refresh(db_persona)
    return db_persona

--- Contenido de app/crud\crud_usuario_completo.py ---

from datetime import datetime
from sqlalchemy import func
from sqlalchemy.orm import Session
from app.models import Usuario, Persona, Rol
from app.schemas import UsuarioCompletoCreacionSchema, UsuarioCompletoRespuestaSchema
from app.core.security import get_password_hash
from fastapi import HTTPException

from app.schemas.usuario_completo import UsuarioCompletoActualizacionSchema

def crear_usuario_completo(db: Session, usuario_data: UsuarioCompletoCreacionSchema, creado_por: int):
    # Verificar si el rol existe
    rol = db.query(Rol).filter(Rol.id == usuario_data.rol_id).first()
    if not rol:
        raise HTTPException(status_code=404, detail="Rol no encontrado")

    # Verificar si el email ya existe (incluyendo registros eliminados lógicamente)
    if db.query(Persona).filter(
        Persona.email == usuario_data.persona.email,
        Persona.eliminado_en.is_(None)
    ).first():
        raise HTTPException(status_code=400, detail="El email ya está registrado")

    # Verificar si el RUT ya existe (incluyendo registros eliminados lógicamente)
    if db.query(Persona).filter(
        Persona.rut == usuario_data.persona.rut,
        Persona.eliminado_en.is_(None)
    ).first():
        raise HTTPException(status_code=400, detail="El RUT ya está registrado")

    # Verificar si el nombre de usuario ya existe
    if db.query(Usuario).filter(Usuario.nombre_usuario == usuario_data.usuario.nombre_usuario).first():
        raise HTTPException(status_code=400, detail="El nombre de usuario ya está en uso")

    # Crear la persona
    nueva_persona = Persona(**usuario_data.persona.model_dump(), creado_por=creado_por)
    db.add(nueva_persona)
    db.flush()

    # Crear el usuario
    nuevo_usuario = Usuario(
        nombre_usuario=usuario_data.usuario.nombre_usuario,
        hash_contrasena=get_password_hash(usuario_data.usuario.contrasena),
        esta_activo=usuario_data.usuario.esta_activo,
        es_superusuario=usuario_data.usuario.es_superusuario,
        persona_id=nueva_persona.id,
        rol_id=usuario_data.rol_id,
        creado_por=creado_por
    )
    db.add(nuevo_usuario)
    db.commit()
    db.refresh(nuevo_usuario)

    return nuevo_usuario

def actualizar_usuario_completo(
    db: Session, 
    usuario_id: int, 
    usuario_data: UsuarioCompletoActualizacionSchema,
    actualizado_por: int
):
    db_usuario = db.query(Usuario).filter(Usuario.id == usuario_id).first()
    if not db_usuario:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")

    # Actualizar datos de la persona
    if usuario_data.persona:
        persona_data = usuario_data.persona.model_dump(exclude_unset=True)
        
        # Verificar unicidad del RUT si se está actualizando
        if 'rut' in persona_data:
            existing_rut = db.query(Persona).filter(
                Persona.rut == persona_data['rut'],
                Persona.id != db_usuario.persona_id,
                Persona.eliminado_en.is_(None)
            ).first()
            if existing_rut:
                raise HTTPException(status_code=400, detail="El RUT ya está registrado")
                
        for key, value in persona_data.items():
            setattr(db_usuario.persona, key, value)
        db_usuario.persona.actualizado_por = actualizado_por

    # Actualizar datos del usuario
    if usuario_data.usuario:
        for key, value in usuario_data.usuario.model_dump(exclude_unset=True).items():
            setattr(db_usuario, key, value)
    
    # Actualizar rol si se proporciona
    if usuario_data.rol_id is not None:
        rol = db.query(Rol).filter(Rol.id == usuario_data.rol_id).first()
        if not rol:
            raise HTTPException(status_code=404, detail="Rol no encontrado")
        db_usuario.rol_id = usuario_data.rol_id

    db_usuario.actualizado_por = actualizado_por

    db.commit()
    db.refresh(db_usuario)
    return db_usuario

def obtener_usuario_completo(db: Session, usuario_id: int):
    return db.query(Usuario).filter(Usuario.id == usuario_id).first()

def listar_usuarios_completos(db: Session, skip: int = 0, limit: int = 100):
    total = db.query(func.count(Usuario.id)).scalar()
    usuarios = db.query(Usuario).offset(skip).limit(limit).all()
    return usuarios, total

--- Contenido de app/middleware\actividad_middleware.py ---

from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from sqlalchemy.orm import Session
from app.core.database import SessionLocal
from app.models.actividad_usuario import ActividadUsuario
from app.core.auth import get_current_user
from app.core.config import settings

class ActividadMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # Prefijos de rutas a excluir
        prefijos_excluidos = [
            "/docs",
            "/openapi.json",
            f"{settings.API_V1_STR}/authentication/"
        ]
        
        # Verificar si la ruta actual comienza con alguno de los prefijos excluidos
        if any(request.url.path.startswith(prefijo) for prefijo in prefijos_excluidos):
            return await call_next(request)

        response = await call_next(request)

        # Solo registrar actividad para respuestas exitosas
        if 200 <= response.status_code < 400:
            db = SessionLocal()
            try:
                usuario = await get_current_user(request, db)
                
                # Obtener la entidad y la acción del path
                path_parts = request.url.path.split("/")
                entidad = path_parts[3] if len(path_parts) > 3 else "desconocida"
                accion = self.obtener_accion(request.method, path_parts)
                
                descripcion = f"{accion.capitalize()} de {entidad}"
                if len(path_parts) > 4 and path_parts[4].isdigit():
                    descripcion += f" (ID: {path_parts[4]})"
                
                nueva_actividad = ActividadUsuario(
                    usuario_id=usuario.id,
                    tipo_actividad=f"{request.method}_{entidad}",
                    descripcion=descripcion,
                    direccion_ip=request.client.host,
                    agente_usuario=request.headers.get("user-agent"),
                    endpoint=request.url.path
                )
                db.add(nueva_actividad)
                db.commit()
            except Exception as e:
                # Log the error, but don't interrupt the response
                print(f"Error registering activity: {e}")
            finally:
                db.close()

        return response

    def obtener_accion(self, method, path_parts):
        if method == "GET":
            return "consulta" if len(path_parts) > 4 else "listado"
        elif method == "POST":
            return "restauración" if path_parts[-1] == "restaurar" else "creación"
        elif method == "PUT":
            return "actualización"
        elif method == "DELETE":
            return "eliminación"
        else:
            return "acción desconocida"

--- Contenido de app/models\actividad_usuario.py ---

from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, func
from app.core.database import Base

class ActividadUsuario(Base):
    __tablename__ = "actividad_usuario"

    id = Column(Integer, primary_key=True, index=True)
    usuario_id = Column(Integer, ForeignKey("usuario.id"))
    tipo_actividad = Column(String(50), nullable=False)
    descripcion = Column(Text)
    fecha_hora = Column(DateTime(timezone=True), server_default=func.now())
    direccion_ip = Column(String(45))
    agente_usuario = Column(Text)
    endpoint = Column(String(255))

--- Contenido de app/models\auditable.py ---

from sqlalchemy import Column, Integer, DateTime
from sqlalchemy.sql import func

class Auditable:
    creado_en = Column(DateTime(timezone=True), server_default=func.now())
    creado_por = Column(Integer, nullable=True)
    actualizado_en = Column(DateTime(timezone=True), onupdate=func.now())
    actualizado_por = Column(Integer, nullable=True)
    eliminado_en = Column(DateTime(timezone=True), nullable=True)  # Cambiado de Integer a DateTime
    eliminado_por = Column(Integer, nullable=True)

--- Contenido de app/models\permiso.py ---

from sqlalchemy import Column, Integer, String, Text
from sqlalchemy.orm import relationship
from app.core.database import Base
from app.models.auditable import Auditable

class Permiso(Base, Auditable):
    __tablename__ = "permiso"

    id = Column(Integer, primary_key=True, index=True)
    nombre = Column(String(50), unique=True, index=True)
    descripcion = Column(Text)

    roles = relationship("Rol", secondary="rol_permiso", back_populates="permisos")

--- Contenido de app/models\persona.py ---

from sqlalchemy import Column, Integer, String, Date
from sqlalchemy.orm import relationship
from app.core.database import Base
from app.models.auditable import Auditable

class Persona(Base, Auditable):
    __tablename__ = "persona"

    id = Column(Integer, primary_key=True, index=True)
    nombre = Column(String, index=True)
    apellido = Column(String, index=True)
    fecha_nacimiento = Column(Date)
    email = Column(String, unique=True, index=True)
    rut = Column(String(12), unique=True, index=True)
    
    # Relación con Usuario
    usuario = relationship("Usuario", back_populates="persona", uselist=False)

--- Contenido de app/models\rol.py ---

from sqlalchemy import Column, Integer, String, Text
from sqlalchemy.orm import relationship
from app.core.database import Base
from .auditable import Auditable

class Rol(Base, Auditable):
    __tablename__ = "rol"

    id = Column(Integer, primary_key=True, index=True)
    nombre = Column(String(50), unique=True, index=True)
    descripcion = Column(Text)

    # Actualizamos la relación con Usuario
    usuarios = relationship("Usuario", back_populates="rol")
    permisos = relationship("Permiso", secondary="rol_permiso", back_populates="roles")

--- Contenido de app/models\rol_permiso.py ---

from sqlalchemy import Column, ForeignKey, Integer
from app.core.database import Base
from app.models.auditable import Auditable

class RolPermiso(Base, Auditable):
    __tablename__ = "rol_permiso"

    rol_id = Column(Integer, ForeignKey("rol.id"), primary_key=True)
    permiso_id = Column(Integer, ForeignKey("permiso.id"), primary_key=True)

--- Contenido de app/models\sesion_usuario.py ---

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from app.core.database import Base

class SesionUsuario(Base):
    __tablename__ = "sesion_usuario"

    id = Column(Integer, primary_key=True, index=True)
    usuario_id = Column(Integer, ForeignKey("usuario.id"))
    token_sesion = Column(String(255), unique=True, index=True)
    direccion_ip = Column(String(45))
    agente_usuario = Column(String(255))
    inicio_sesion = Column(DateTime)
    fin_sesion = Column(DateTime, nullable=True)

    usuario = relationship("Usuario", back_populates="sesiones")

--- Contenido de app/models\usuario.py ---

from sqlalchemy import Boolean, Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from app.core.database import Base
from app.models.auditable import Auditable

class Usuario(Base, Auditable):
    __tablename__ = "usuario"

    id = Column(Integer, primary_key=True, index=True)
    nombre_usuario = Column(String, unique=True, index=True)
    hash_contrasena = Column(String)
    esta_activo = Column(Boolean, default=True)
    es_superusuario = Column(Boolean, default=False)

    persona_id = Column(Integer, ForeignKey("persona.id"))
    persona = relationship("Persona", back_populates="usuario")

    # Cambiamos la relación con Rol
    rol_id = Column(Integer, ForeignKey("rol.id"))
    rol = relationship("Rol", back_populates="usuarios")
    
    sesiones = relationship("SesionUsuario", back_populates="usuario")

--- Contenido de app/models\__init__.py ---

from .rol import Rol
from .permiso import Permiso
from .rol_permiso import RolPermiso
from .usuario import Usuario
from .persona import Persona
from .auditable import Auditable
from .sesion_usuario import SesionUsuario

--- Contenido de app/schemas\auth.py ---

from pydantic import BaseModel, EmailStr
from datetime import date
from typing import List, Optional

class PermisoRespuesta(BaseModel):
    id: int
    nombre: str
    descripcion: Optional[str] = None

    class Config:
        from_attributes = True

class RolRespuesta(BaseModel):
    id: int
    nombre: str
    descripcion: Optional[str] = None
    permisos: List[PermisoRespuesta]

    class Config:
        from_attributes = True

class UsuarioRespuesta(BaseModel):
    id: int
    nombre_usuario: str
    esta_activo: bool
    es_superusuario: bool
    nombre: str
    apellido: str
    fecha_nacimiento: date
    email: EmailStr
    rol: RolRespuesta

    class Config:
        from_attributes = True

class TokenRespuesta(BaseModel):
    access_token: str
    token_type: str

class TokenPayload(BaseModel):
    nombre_usuario: str | None = None

--- Contenido de app/schemas\paginacion.py ---

from typing import Generic, TypeVar, List, Optional
from pydantic import BaseModel
from pydantic.generics import GenericModel

T = TypeVar('T')

class PaginacionBase(GenericModel, Generic[T]):
    total: int
    page: int
    pages: int
    limit: int
    prev_page: Optional[int]
    next_page: Optional[int]
    items: List[T]

--- Contenido de app/schemas\persona.py ---

from pydantic import BaseModel, EmailStr, field_validator
from datetime import date, datetime
from typing import Optional
from app.schemas.paginacion import PaginacionBase
from app.utils.rut_util import validar_rut, formatear_rut
from fastapi import HTTPException

class PersonaBase(BaseModel):
    nombre: str
    apellido: str
    fecha_nacimiento: date
    email: EmailStr
    rut: str
    
    @field_validator('rut')
    @classmethod
    def validar_formato_rut(cls, v: str) -> str:
        if not validar_rut(v):
            raise HTTPException(
                status_code=400,
                detail="RUT no válido"
            )
        return formatear_rut(v)

class PersonaCreacionSchema(PersonaBase):
    pass

class PersonaActualizacionSchema(BaseModel):
    nombre: Optional[str] = None
    apellido: Optional[str] = None
    fecha_nacimiento: Optional[date] = None
    email: Optional[EmailStr] = None
    rut: Optional[str] = None
    
    @field_validator('rut')
    @classmethod
    def validar_formato_rut(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        if not validar_rut(v):
            raise HTTPException(
                status_code=400,
                detail="RUT no válido"
            )
        return formatear_rut(v)

class PersonaRespuestaSchema(PersonaBase):
    id: int
    creado_en: Optional[datetime]
    creado_por: Optional[int]
    actualizado_en: Optional[datetime]
    actualizado_por: Optional[int]

    class Config:
        from_attributes = True

class PersonaPaginada(PaginacionBase[PersonaRespuestaSchema]):
    pass

--- Contenido de app/schemas\rol.py ---

from pydantic import BaseModel
from typing import Optional

class RolCreacionSchema(BaseModel):
    nombre: str
    descripcion: Optional[str] = None

class RolRespuestaSchema(RolCreacionSchema):
    id: int

    class Config:
        from_attributes = True

--- Contenido de app/schemas\usuario.py ---

from pydantic import BaseModel

class UsuarioCreacionSchema(BaseModel):
    nombre_usuario: str
    contrasena: str
    esta_activo: bool = True
    es_superusuario: bool = False

class UsuarioRespuestaSchema(BaseModel):
    id: int
    nombre_usuario: str
    esta_activo: bool
    es_superusuario: bool

    class Config:
        from_attributes = True

--- Contenido de app/schemas\usuario_completo.py ---

from datetime import date
from typing import Optional
from pydantic import BaseModel

from app.schemas.paginacion import PaginacionBase
from .persona import PersonaCreacionSchema, PersonaRespuestaSchema
from .rol import RolRespuestaSchema
from .usuario import UsuarioCreacionSchema, UsuarioRespuestaSchema

# CREACION
class UsuarioCompletoCreacionSchema(BaseModel):
    persona: PersonaCreacionSchema
    usuario: UsuarioCreacionSchema
    rol_id: int

class UsuarioCompletoRespuestaSchema(UsuarioRespuestaSchema):
    persona: PersonaRespuestaSchema
    rol: RolRespuestaSchema
    creado_por: Optional[int] = None
    actualizado_por: Optional[int] = None
    
# ACTUALIZACION
class PersonaActualizacionSchema(BaseModel):
    nombre: Optional[str] = None
    apellido: Optional[str] = None
    fecha_nacimiento: Optional[date] = None
    rut: Optional[str] = None

class UsuarioActualizacionSchema(BaseModel):
    esta_activo: Optional[bool] = None
    es_superusuario: Optional[bool] = None

class UsuarioCompletoActualizacionSchema(BaseModel):
    persona: Optional[PersonaActualizacionSchema] = None
    usuario: Optional[UsuarioActualizacionSchema] = None
    rol_id: Optional[int] = None
    
# PAGINACION
class UsuarioCompletoPaginado(PaginacionBase[UsuarioCompletoRespuestaSchema]):
    pass

--- Contenido de app/schemas\__init__.py ---

from .persona import PersonaCreacionSchema, PersonaRespuestaSchema
from .rol import RolCreacionSchema, RolRespuestaSchema
from .usuario import UsuarioCreacionSchema, UsuarioRespuestaSchema
from .usuario_completo import UsuarioCompletoCreacionSchema, UsuarioCompletoRespuestaSchema

--- Contenido de app/utils\actividad_util.py ---

from sqlalchemy.orm import Session
from fastapi import Request
from app.models.actividad_usuario import ActividadUsuario
from app.schemas.auth import UsuarioRespuesta

async def registrar_actividad(
    db: Session,
    usuario: UsuarioRespuesta,
    request: Request,
    tipo_actividad: str,
    descripcion: str
):
    nueva_actividad = ActividadUsuario(
        usuario_id=usuario.id,
        tipo_actividad=tipo_actividad,
        descripcion=descripcion,
        direccion_ip=request.client.host,
        agente_usuario=request.headers.get("user-agent"),
        endpoint=request.url.path
    )
    db.add(nueva_actividad)
    db.commit()

--- Contenido de app/utils\rut_util.py ---

def limpiar_rut(rut: str) -> str:
    """
    Limpia el RUT de puntos y guiones, dejando solo números y la letra K si existe.
    """
    return rut.upper().replace(".", "").replace("-", "")

def calcular_digito_verificador(rut_numero: str) -> str:
    """
    Calcula el dígito verificador de un RUT.
    """
    try:
        serie = [2, 3, 4, 5, 6, 7]
        suma = 0
        
        for i, num in enumerate(reversed(rut_numero)):
            suma += int(num) * serie[i % len(serie)]
        
        resto = suma % 11
        if resto == 0:
            return '0'
        elif resto == 1:
            return 'K'
        else:
            return str(11 - resto)
    except:
        return ''

def validar_rut(rut: str) -> bool:
    """
    Valida un RUT chileno.
    Retorna True si el RUT es válido, False en caso contrario.
    """
    try:
        rut_limpio = limpiar_rut(rut)
        
        # Verificar longitud mínima y máxima
        if len(rut_limpio) < 2 or len(rut_limpio) > 9:
            return False
        
        # Separar número y dígito verificador
        rut_numero = rut_limpio[:-1]
        digito_verificador = rut_limpio[-1]
        
        # Verificar que el número del RUT sea válido
        if not rut_numero.isdigit():
            return False
        
        # Verificar que el dígito verificador sea válido (número o 'K')
        if not (digito_verificador.isdigit() or digito_verificador == 'K'):
            return False
        
        # Calcular y comparar el dígito verificador
        digito_calculado = calcular_digito_verificador(rut_numero)
        return digito_verificador == digito_calculado
        
    except:
        return False

def formatear_rut(rut: str) -> str:
    """
    Formatea un RUT a formato estándar (sin puntos, con guión)
    Ejemplo: 12345678-9
    """
    rut_limpio = limpiar_rut(rut)
    return f"{rut_limpio[:-1]}-{rut_limpio[-1]}"

--- Contenido de app/utils\sesion_util.py ---

from sqlalchemy.orm import Session
from app.models.sesion_usuario import SesionUsuario
from fastapi import Request
from datetime import datetime

def registrar_inicio_sesion(db: Session, usuario_id: int, token: str, request: Request) -> SesionUsuario:
    nueva_sesion = SesionUsuario(
        usuario_id=usuario_id,
        token_sesion=token,
        direccion_ip=request.client.host,
        agente_usuario=request.headers.get("user-agent"),
        inicio_sesion=datetime.utcnow()
    )
    db.add(nueva_sesion)
    db.commit()
    db.refresh(nueva_sesion)
    return nueva_sesion

def registrar_fin_sesion(db: Session, token: str) -> bool:
    sesion = db.query(SesionUsuario).filter(SesionUsuario.token_sesion == token).first()
    if sesion:
        sesion.fin_sesion = datetime.utcnow()
        db.commit()
        return True
    return False